#+SETUPFILE: https://hozendev.github.io/hozen-style/hozen_html_style.setup

#+TITLE: ZZ1 SEMAINE 1
#+AUTHOR: DUREL Enzo VILLEPREUX Thibault LEROY Louis
#+LANGUAGE: fr

* Projet Individuel
** Louis
*** Z Fenetre
#+attr_html: :width 800px
[[./data/img/Louis_p2.gif]]

*** Carré Fusion
#+attr_html: :width 800px
[[./data/img/Louis_p1.gif]]

*** Sprite
#+attr_html: :width 800px
[[./data/img/Louis_p3.gif]]

** Thibault
*** Fenetre Piège
#+attr_html: :width 800px
[[./data/img/Tib_p2.gif]]

*** Rectangle Latéraux Fusion
#+attr_html: :width 800px
[[./data/img/Tib_p1.gif]]

*** Super Mario Frod

#+attr_html: :width 800px
[[./data/img/Tib_p31.gif]]

#+attr_html: :width 800px
[[./data/img/Tib_p32.gif]]

** Enzo
*** Explosion
#+attr_html: :width 800px
[[./data/img/Enzo_explosion_2.gif]]

*** Simulation Vent
#+attr_html: :width 800px
[[./data/img/Enzo_simulation.gif]]

*** Parallax + animation voiture
#+attr_html: :width 800px
[[./data/img/Enzo_parallax.gif]]

* Problemes du Voyageur
** Présentation

L'énoncé du problème du voyageur de commerce est le suivant : étant donné n villes et les distances entre toutes les paires de villes, trouver un chemin de longueur totale minimale qui passe exactement une fois par chaque ville et revienne à la ville de départ.

** Floyd Warshall

#+begin_example
Sortie : matrice, des plus courtes distances
Entrée : graph, graph qui contient les points et distances initialisées
Var    : matrice, des plus courtes distances

Initialisation matrice = +∞

FONCTION floyd_warshall (graph)
|    allocation de la matrice
|    initialisation de celle ci avec les distances des arcs existants
|
|    POUR k de 0 a la taille de la matrice FAIRE:
|    |    POUR chaque cellule de la matrice FAIRE:
|    |    |    SI le chemin passant par k entre les deux coefs de la matrice est plus court que celui stocké ALORS
|    |    |    |    On met a jour la distance avec celle de ce nouveau chemin
|    |    |    FSI
|    |    FAIT
|    FAIT
|
|    retourner matrice
FIN
#+end_example

** GLOUTON EXHAUSTIVE

Principe: Prendre le meilleur à chaque itération

#+begin_example
Sortie : distance euclidienne cycle minimum
Entrée : tableau distance Floyd Warshall, nb_sommet
Var    : tableau visitée , case = 0 non visité sinon 1

Initialisation dist_min_trouve = +∞

glouton_exhaustive :
|           
|     POUR chaque sommet du graphe :
|     |     FAIRE jusqu'à tous les sommets sont visités
|     |     |    aller au prochain sommet le moins loin en le marquant comme visité en s'aidant de la matrice de floyd W,
|     |     |    ne pas oublié de revenir au depart pour le dernier sommet
|     |     |_FIN
|     |     regarder si la distance du cycle est plus petite que dist_min_trouve, si oui la modifier
|     |_FAIT
|
|     retourner dist_min_trouve
|     
FIN ALGO
#+end_example

** RECUIT SIMULÉ

Principe: Prendre le meilleur avec une probabilité qui diminue au cours du temps

#+begin_example
FONCTION resolution_recuit_simulé(distance,taille)
|    initialisation des parametre; [temperature,taux...]
|    initialisation d'une solution; [0,1,2,....]
|
|    TANT QUE tempertaure>seuil FAIRE
|    |    mélange la solution
|    |    compare cette nouvelle solution
|    |    SI nouvelle solution est meilleur ou avec une probabilité fonction de la temperature ALORS
|    |    |   on met a jour la dist et la solution minimales
|    |    FSI
|    |    met a jour la temperature
|    FAIT
|
|    libere les tableaux
|
|    retourne la distance
FIN ALGO
#+end_example

** COLONIE DE FOURMI
*** Cacul Probabilité sur les sommets de chaque fourmi
*** Mise à jour des distances d'une fourmi
*** Mise à jour des phéromones des fourmis
** Structure du code
*** Makefile
*** build
*** src
1.1 graph

Contient la structure d'un graph.

Contient la structure de la représentation SDL d'un graph.

Contient toutes les fonctions associées aux graphes.

1.2 resolution

Contient les codes des algorithmes de résolution (fourmi, recuit simulé, ...).

1.3 game

Contient les gestions des différentes états du jeu.

Structure jeu qui contient tout les attributs d'un jeu.

Structure état du jeu qui contient les attributs qui définissent l'état dans lequel est le jeu.

1.4 utils
*** data
* Chef d'oeuvre
